<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lisp REPL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            padding: 2rem;
            display: flex;
            gap: 2rem;
            min-height: 100vh;
        }
        .repl-container {
            flex: 1;
            max-width: 800px;
            margin: 0 auto;
            background-color: #2d3748;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            height: calc(100vh - 4rem);
        }
        .sidebar {
            width: 300px;
            background-color: #2d3748;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            padding: 1.5rem;
            overflow-y: auto;
            max-height: calc(100vh - 4rem);
        }
        .sidebar h3 {
            color: #f7fafc;
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
            border-bottom: 2px solid #4a5568;
            padding-bottom: 0.5rem;
        }
        .function-category {
            margin-bottom: 1.5rem;
        }
        .function-category h4 {
            color: #a0aec0;
            font-size: 1rem;
            font-weight: semibold;
            margin-bottom: 0.5rem;
        }
        .function-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .function-list li {
            color: #d1d5db;
            font-family: monospace;
            font-size: 0.875rem;
            padding: 0.25rem 0.5rem;
            margin-bottom: 0.25rem;
            background-color: #374151;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .function-list li:hover {
            background-color: #4b5563;
        }
        .function-list li.special-form {
            background-color: #3b4f66;
        }
        .function-list li.macro {
            background-color: #4c3a5b;
        }
        .impl-marker {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            border: 1px solid #9ca3af;
        }
        .impl-marker.hardcoded {
            background-color: #9ca3af;
        }
        .impl-marker.lisp {
            background-color: transparent;
        }
        .tooltip {
            position: relative;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #1f2937;
            color: #d1d5db;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: fixed;
            z-index: 9999;
            left: 320px;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 5px;
            font-size: 0.75rem;
            line-height: 1.3;
            border: 1px solid #4b5563;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-height: 200px;
            overflow-y: auto;
            pointer-events: none;
        }
        .tooltip .tooltiptext::after {
            display: none;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
        }
        .tooltiptext .example {
            color: #fbbf24;
            font-family: monospace;
            margin-top: 4px;
            font-size: 0.7rem;
        }
        .repl-output {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 1rem;
            border-radius: 0.5rem;
            flex: 2;
            overflow-y: scroll;
            white-space: pre-wrap;
            font-family: monospace;
        }
        .repl-input {
            width: 100%;
            background-color: #4a5568;
            color: #d1d5db;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 2px solid #4a5568;
            font-family: monospace;
            resize: none;
            flex: 1;
            min-height: 0;
        }
        .repl-input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        .title {
            font-size: 2rem;
            font-weight: bold;
            color: #f7fafc;
            text-align: center;
        }
        .subtitle {
            font-size: 1rem;
            color: #a0aec0;
            text-align: center;
        }
        .prompt {
            color: #4ade80;
        }
        .result {
            color: #fcd34d;
        }
        .repl-controls {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            align-items: center;
        }
        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: bold;
            transition: background-color 0.2s ease, transform 0.1s ease;
            cursor: pointer;
            border: none;
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }
        .btn-primary:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .btn-secondary {
            display: none; /* Hide the button as dark mode is now permanent */
        }
    </style>
</head>
<body>

<div class="sidebar">
    <h3>Available Functions</h3>
    
    <div class="legend" style="margin-bottom: 1rem; padding: 0.5rem; background-color: #374151; border-radius: 0.25rem; font-size: 0.75rem;">
        <div style="display: flex; align-items: center; margin-bottom: 0.25rem;">
            <span class="impl-marker hardcoded" style="margin-right: 6px;"></span>
            <span style="color: #d1d5db;">Hardcoded (JavaScript)</span>
        </div>
        <div style="display: flex; align-items: center;">
            <span class="impl-marker lisp" style="margin-right: 6px;"></span>
            <span style="color: #d1d5db;">Implemented in Lisp</span>
        </div>
    </div>
    
    <div class="function-category">
        <h4>Special Forms</h4>
        <ul class="function-list">
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>if
                <span class="tooltiptext">Conditional expression - evaluates test and returns conseq if true, alt if false<div class="example">(if (> x 0) "positive" "non-positive")</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>cond
                <span class="tooltiptext">Multi-way conditional - tests conditions in order and evaluates the first matching clause<div class="example">(cond ((< x 0) "negative") ((= x 0) "zero") (else "positive"))</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>define
                <span class="tooltiptext">Binds a value to a symbol in the global environment<div class="example">(define pi 3.14159)</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>let
                <span class="tooltiptext">Creates local bindings for variables within a scope<div class="example">(let ((x 5) (y 3)) (+ x y))</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>let*
                <span class="tooltiptext">Sequential let - each binding can use previous bindings<div class="example">(let* ((x 5) (y (+ x 3))) (+ x y))</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>quote
                <span class="tooltiptext">Returns the literal expression without evaluating it<div class="example">(quote (+ 1 2)) ; returns (+ 1 2), not 3</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>set!
                <span class="tooltiptext">Modifies the value of an existing variable<div class="example">(set! x 10)</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>lambda
                <span class="tooltiptext">Creates an anonymous function with parameters and body<div class="example">(lambda (x y) (+ x y))</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>and
                <span class="tooltiptext">Logical AND - returns false if any argument is false, otherwise returns the last argument<div class="example">(and (> x 0) (< x 10))</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>or
                <span class="tooltiptext">Logical OR - returns the first truthy argument, or false if all are false<div class="example">(or (null? x) (= x 0))</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>begin
                <span class="tooltiptext">Evaluates expressions in sequence and returns the value of the last one<div class="example">(begin (define x 5) (+ x 3))</div></span>
            </li>
            <li class="special-form tooltip"><span class="impl-marker hardcoded"></span>defmacro
                <span class="tooltiptext">Defines a macro that transforms code at evaluation time<div class="example">(defmacro when (test &rest body) (list 'if test (cons 'begin body)))</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Macros</h4>
        <ul class="function-list">
            <li class="macro tooltip"><span class="impl-marker lisp"></span>defun
                <span class="tooltiptext">Defines a named function - syntactic sugar for define + lambda<div class="example">(defun square (x) (* x x))</div></span>
            </li>
            <li class="macro tooltip"><span class="impl-marker lisp"></span>progn
                <span class="tooltiptext">Evaluates multiple expressions in sequence, like begin<div class="example">(progn (define x 5) (+ x 2))</div></span>
            </li>
            <li class="macro tooltip"><span class="impl-marker lisp"></span>when
                <span class="tooltiptext">Executes body only if condition is true<div class="example">(when (> x 0) (print "positive") (+ x 1))</div></span>
            </li>
            <li class="macro tooltip"><span class="impl-marker lisp"></span>unless
                <span class="tooltiptext">Executes body only if condition is false<div class="example">(unless (null? lst) (print "not empty"))</div></span>
            </li>
            <li class="macro tooltip"><span class="impl-marker lisp"></span>dotimes
                <span class="tooltiptext">Executes body a specified number of times with loop variable<div class="example">(dotimes (i 5) (print i))</div></span>
            </li>
            <li class="macro tooltip"><span class="impl-marker lisp"></span>cond*
                <span class="tooltiptext">Alternative cond implementation - multi-way conditional with else clause<div class="example">(cond* ((< x 0) "negative") ((= x 0) "zero") (else "positive"))</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Arithmetic</h4>
        <ul class="function-list">
            <li class="tooltip"><span class="impl-marker hardcoded"></span>+
                <span class="tooltiptext">Addition - sums all arguments<div class="example">(+ 1 2 3 4) ; returns 10</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>-
                <span class="tooltiptext">Subtraction - with one arg negates, with multiple subtracts from first<div class="example">(- 10 3 2) ; returns 5</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>*
                <span class="tooltiptext">Multiplication - multiplies all arguments<div class="example">(* 2 3 4) ; returns 24</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>/
                <span class="tooltiptext">Division - divides first argument by subsequent ones<div class="example">(/ 20 4 2) ; returns 2.5</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>mod
                <span class="tooltiptext">Modulo operation - returns remainder of division<div class="example">(mod 17 5) ; returns 2</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>abs
                <span class="tooltiptext">Absolute value - returns non-negative value<div class="example">(abs -5) ; returns 5</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>round
                <span class="tooltiptext">Rounds to nearest integer<div class="example">(round 3.7) ; returns 4</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>max
                <span class="tooltiptext">Returns the largest of the arguments<div class="example">(max 3 7 2 9 1) ; returns 9</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>min
                <span class="tooltiptext">Returns the smallest of the arguments<div class="example">(min 3 7 2 9 1) ; returns 1</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>square
                <span class="tooltiptext">Returns the square of a number<div class="example">(square 5) ; returns 25</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>cube
                <span class="tooltiptext">Returns the cube of a number<div class="example">(cube 3) ; returns 27</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>power
                <span class="tooltiptext">Raises base to the power of exponent<div class="example">(power 2 8) ; returns 256</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>factorial
                <span class="tooltiptext">Returns the factorial of a number<div class="example">(factorial 5) ; returns 120</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>sum
                <span class="tooltiptext">Sums all elements in a list<div class="example">(sum (list 1 2 3 4)) ; returns 10</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>product
                <span class="tooltiptext">Multiplies all elements in a list<div class="example">(product (list 2 3 4)) ; returns 24</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>average
                <span class="tooltiptext">Calculates the mean of elements in a list<div class="example">(average (list 2 4 6 8)) ; returns 5</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Comparison</h4>
        <ul class="function-list">
            <li class="tooltip"><span class="impl-marker hardcoded"></span>=
                <span class="tooltiptext">Tests for equality between two values<div class="example">(= 5 5) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>>
                <span class="tooltiptext">Tests if first argument is greater than second<div class="example">(> 7 3) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span><
                <span class="tooltiptext">Tests if first argument is less than second<div class="example">(< 3 7) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>>=
                <span class="tooltiptext">Tests if first argument is greater than or equal to second<div class="example">(>= 7 7) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span><=
                <span class="tooltiptext">Tests if first argument is less than or equal to second<div class="example">(<= 3 7) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>eq
                <span class="tooltiptext">Tests for object identity (same as =)<div class="example">(eq 'x 'x) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>equal?
                <span class="tooltiptext">Tests for structural equality, including nested structures<div class="example">(equal? (list 1 2) (list 1 2)) ; returns #t</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Lists</h4>
        <ul class="function-list">
            <li class="tooltip"><span class="impl-marker hardcoded"></span>car
                <span class="tooltiptext">Returns the first element of a list<div class="example">(car (list 1 2 3)) ; returns 1</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>cdr
                <span class="tooltiptext">Returns all elements except the first<div class="example">(cdr (list 1 2 3)) ; returns (2 3)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>cadr
                <span class="tooltiptext">Returns the second element of a list (car of cdr)<div class="example">(cadr (list 1 2 3)) ; returns 2</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>caddr
                <span class="tooltiptext">Returns the third element of a list<div class="example">(caddr (list 1 2 3 4)) ; returns 3</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>cons
                <span class="tooltiptext">Constructs a list by adding element to front<div class="example">(cons 1 (list 2 3)) ; returns (1 2 3)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>list
                <span class="tooltiptext">Creates a list from its arguments<div class="example">(list 1 2 3 4) ; returns (1 2 3 4)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>append
                <span class="tooltiptext">Concatenates two lists<div class="example">(append (list 1 2) (list 3 4)) ; returns (1 2 3 4)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>reverse
                <span class="tooltiptext">Reverses the order of elements in a list<div class="example">(reverse (list 1 2 3)) ; returns (3 2 1)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>length
                <span class="tooltiptext">Returns the number of elements in a list<div class="example">(length (list 1 2 3 4)) ; returns 4</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>first
                <span class="tooltiptext">Returns the first element (same as car)<div class="example">(first (list 1 2 3)) ; returns 1</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>second
                <span class="tooltiptext">Returns the second element<div class="example">(second (list 1 2 3)) ; returns 2</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>third
                <span class="tooltiptext">Returns the third element<div class="example">(third (list 1 2 3)) ; returns 3</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>last
                <span class="tooltiptext">Returns the last element of a list<div class="example">(last (list 1 2 3 4)) ; returns 4</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>butlast
                <span class="tooltiptext">Returns all elements except the last<div class="example">(butlast (list 1 2 3 4)) ; returns (1 2 3)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>nth
                <span class="tooltiptext">Returns the element at the specified index (0-based)<div class="example">(nth 2 (list 10 20 30 40)) ; returns 30</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>take
                <span class="tooltiptext">Returns the first n elements of a list<div class="example">(take 3 (list 1 2 3 4 5)) ; returns (1 2 3)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>drop
                <span class="tooltiptext">Returns the list with first n elements removed<div class="example">(drop 2 (list 1 2 3 4 5)) ; returns (3 4 5)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>flatten
                <span class="tooltiptext">Flattens nested lists into a single list<div class="example">(flatten (list 1 (list 2 3) 4)) ; returns (1 2 3 4)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>map
                <span class="tooltiptext">Applies function to each element, returns new list<div class="example">(map square (list 1 2 3)) ; returns (1 4 9)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>filter
                <span class="tooltiptext">Returns elements that satisfy the predicate<div class="example">(filter positive? (list -1 2 -3 4)) ; returns (2 4)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>reduce
                <span class="tooltiptext">Combines list elements using a function and initial value<div class="example">(reduce + 0 (list 1 2 3 4)) ; returns 10</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>zip
                <span class="tooltiptext">Combines two lists into pairs<div class="example">(zip (list 1 2) (list 'a 'b)) ; returns ((1 a) (2 b))</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>range
                <span class="tooltiptext">Generates a list of numbers from start to end<div class="example">(range 1 5) ; returns (1 2 3 4)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>find
                <span class="tooltiptext">Returns first element satisfying predicate<div class="example">(find positive? (list -1 2 3)) ; returns 2</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>member?
                <span class="tooltiptext">Tests if element is in the list<div class="example">(member? 3 (list 1 2 3 4)) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>position
                <span class="tooltiptext">Returns the index of element in list<div class="example">(position 'c (list 'a 'b 'c 'd)) ; returns 2</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>sort
                <span class="tooltiptext">Sorts list using comparison function<div class="example">(sort (list 3 1 4 2) <) ; returns (1 2 3 4)</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Predicates</h4>
        <ul class="function-list">
            <li class="tooltip"><span class="impl-marker hardcoded"></span>null?
                <span class="tooltiptext">Tests if list is empty<div class="example">(null? (list)) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>pair?
                <span class="tooltiptext">Tests if value is a non-empty list<div class="example">(pair? (list 1 2)) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>list?
                <span class="tooltiptext">Tests if value is a proper list<div class="example">(list? (list 1 2 3)) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>number?
                <span class="tooltiptext">Tests if value is a number<div class="example">(number? 42) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>symbol?
                <span class="tooltiptext">Tests if value is a symbol<div class="example">(symbol? 'hello) ; returns #t</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>procedure?
                <span class="tooltiptext">Tests if value is a function<div class="example">(procedure? +) ; returns #t</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Logic & Control</h4>
        <ul class="function-list">
            <li class="tooltip"><span class="impl-marker lisp"></span>not
                <span class="tooltiptext">Logical negation - returns opposite boolean value<div class="example">(not #t) ; returns #f</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>for-each
                <span class="tooltiptext">Applies function to each list element for side effects<div class="example">(for-each print (list 1 2 3))</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker hardcoded"></span>apply
                <span class="tooltiptext">Calls function with list of arguments<div class="example">(apply + (list 1 2 3 4)) ; returns 10</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>identity
                <span class="tooltiptext">Returns its argument unchanged<div class="example">(identity 42) ; returns 42</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>constantly
                <span class="tooltiptext">Returns a function that always returns the same value<div class="example">((constantly 5) 1 2 3) ; returns 5</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>compose
                <span class="tooltiptext">Creates function composition - applies functions right to left<div class="example">((compose square abs) -3) ; returns 9</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>partial
                <span class="tooltiptext">Partially applies function with some arguments<div class="example">((partial + 10) 5) ; returns 15</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>complement
                <span class="tooltiptext">Returns function that gives opposite boolean result<div class="example">((complement positive?) -5) ; returns #t</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Association Lists</h4>
        <ul class="function-list">
            <li class="tooltip"><span class="impl-marker lisp"></span>assoc
                <span class="tooltiptext">Finds key-value pair in association list<div class="example">(assoc 'b '((a 1) (b 2) (c 3))) ; returns (b 2)</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>alist-get
                <span class="tooltiptext">Gets value for key from association list<div class="example">(alist-get 'b '((a 1) (b 2))) ; returns 2</div></span>
            </li>
            <li class="tooltip"><span class="impl-marker lisp"></span>alist-set
                <span class="tooltiptext">Adds or updates key-value pair in association list<div class="example">(alist-set 'x 10 '((a 1))) ; returns ((x 10) (a 1))</div></span>
            </li>
        </ul>
    </div>

    <div class="function-category">
        <h4>Utility</h4>
        <ul class="function-list">
            <li class="tooltip"><span class="impl-marker hardcoded"></span>error
                <span class="tooltiptext">Throws an error with the given message<div class="example">(error "Something went wrong!")</div></span>
            </li>
        </ul>
    </div>
</div>

<div class="repl-container">
    <h1 class="title">Lisp REPL</h1>
    <p class="subtitle">A simple Lisp interpreter implemented in JavaScript</p>
    <div id="repl-output" class="repl-output"></div>
    <textarea id="repl-input" class="repl-input" rows="5" placeholder="Type a Lisp expression here. Use the button below to run it." spellcheck="false"></textarea>
    <div class="repl-controls">
        <button id="dark-mode-toggle" class="btn btn-secondary">Toggle Dark Mode</button>
        <button id="run-btn" class="btn btn-primary">Run</button>
    </div>
</div>

<script>
    // Lis.js - A Lisp interpreter in JavaScript
    // Based on Peter Norvig's Python implementation
    // Source: https://github.com/norvig/pytudes/blob/c33cd6835a506a57d9fe73e3a8317d49babb13e8/py/lis.py

    // Helper functions
    const toString = (exp) => {
        if (exp === true) {
            return '#t';
        }
        if (exp === false) {
            return '#f';
        }
        if (Array.isArray(exp)) {
            return `(${exp.map(toString).join(' ')})`;
        } else if (typeof exp === 'string' && exp.startsWith('"') && exp.endsWith('"')) {
            // This is a string literal, not a symbol
            return exp;
        } else if (typeof exp === 'string') {
             // Treat as a symbol
            return exp;
        }
        else {
            return exp;
        }
    };

    const parse = (program) => {
        return readFromTokens(tokenize(program));
    };

    const tokenize = (chars) => {
        // Strip out comments from a semicolon to the end of the line
        const charsWithoutComments = chars.replace(/(;.*$)/mg, '');
        // Use a regex to correctly split tokens, including quoted strings
        return charsWithoutComments.match(/"[^"]*"|\(|\)|'|[^\s()']+/g) || [];
    };

    const readFromTokens = (tokens) => {
        if (tokens.length === 0) {
            throw new Error('unexpected EOF');
        }
        const token = tokens.shift();
        if (token === '(') {
            let L = [];
            while (tokens[0] !== ')') {
                L.push(readFromTokens(tokens));
            }
            tokens.shift(); // pop off ')'
            return L;
        } else if (token === ')') {
            throw new Error('unexpected )');
        } else if (token === "'") {
            return ['quote', readFromTokens(tokens)];
        } else {
            return atom(token);
        }
    };

    const atom = (token) => {
        if (token === '#t') {
            return true;
        }
        if (token === '#f') {
            return false;
        }
        // Handle string literals by checking for surrounding quotes
        if (token.startsWith('"') && token.endsWith('"')) {
            return token;
        }
        if (!isNaN(parseFloat(token))) {
            return parseFloat(token);
        }
        // All other tokens are considered symbols (represented as strings)
        return token;
    };
    
    // A robust, native JavaScript implementation of `equal?`
    const deepEqual = (a, b) => {
        if (a === b) {
            return true;
        }
        if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };

    // Env (Environment)
    class Env {
        constructor(parms = [], args = [], outer = null) {
            this.data = {};
            for (let i = 0; i < parms.length; i++) {
                // Symbols are now regular strings
                this.data[parms[i]] = args[i];
            }
            this.outer = outer;
        }

        find(symbol) {
            if (symbol in this.data) {
                return this.data;
            }
            if (this.outer) {
                return this.outer.find(symbol);
            }
            throw new Error(`Symbol not found: ${symbol}`);
        }
    }

    const standardEnv = () => {
        const env = new Env();
        env.data = {
            '+': (...args) => args.reduce((a, b) => a + b, 0),
            '-': (...args) => args.length === 1 ? -args[0] : args.slice(1).reduce((a, b) => a - b, args[0]),
            '*': (...args) => args.reduce((a, b) => a * b, 1),
            '/': (...args) => args.slice(1).reduce((a, b) => a / b, args[0]),
            'mod': (a, b) => a % b,
            '>': (a, b) => a > b,
            '<': (a, b) => a < b,
            '>=': (a, b) => a >= b,
            '<=': (a, b) => a <= b,
            '=': (a, b) => a === b,
            'eq': (a, b) => a === b, 
            'equal?': deepEqual,
            'car': (list) => Array.isArray(list) && list.length > 0 ? list[0] : null,
            'cdr': (list) => Array.isArray(list) && list.length > 1 ? list.slice(1) : [],
            'cons': (a, b) => [a].concat(b),
            'list': (...args) => args,
            'null?': (l) => Array.isArray(l) && l.length === 0,
            'pair?': (x) => Array.isArray(x) && x.length > 0,
            'number?': (x) => typeof x === 'number',
            'procedure?': (x) => typeof x === 'function',
            'round': Math.round,
            // Check for a string that is not a string literal
            'symbol?': (x) => typeof x === 'string' && !x.startsWith('"'),
            'error': (msg) => { throw new Error(msg); },
            'apply': (func, args) => {
                if (typeof func !== 'function') {
                    throw new Error('apply: first argument must be a procedure');
                }
                if (!Array.isArray(args)) {
                    throw new Error('apply: second argument must be a list');
                }
                return func(...args);
            },
            'range': (...args) => {
                let start, end, step = 1;
                if (args.length === 1) {
                    start = 0;
                    end = args[0];
                } else if (args.length === 2) {
                    start = args[0];
                    end = args[1];
                } else if (args.length === 3) {
                    start = args[0];
                    end = args[1];
                    step = args[2];
                } else {
                    throw new Error('range: expects 1, 2, or 3 arguments');
                }
                
                const result = [];
                if (step > 0) {
                    for (let i = start; i < end; i += step) {
                        result.push(i);
                    }
                } else if (step < 0) {
                    for (let i = start; i > end; i += step) {
                        result.push(i);
                    }
                }
                return result;
            },
            'for-each': (func, list) => {
                if (typeof func !== 'function') {
                    throw new Error('for-each: first argument must be a procedure');
                }
                if (!Array.isArray(list)) {
                    throw new Error('for-each: second argument must be a list');
                }
                
                for (let i = 0; i < list.length; i++) {
                    func(list[i]);
                }
                return [];
            },
            'reduce': (func, init, list) => {
                if (typeof func !== 'function') {
                    throw new Error('reduce: first argument must be a procedure');
                }
                if (!Array.isArray(list)) {
                    throw new Error('reduce: third argument must be a list');
                }
                
                let result = init;
                for (let i = 0; i < list.length; i++) {
                    result = func(result, list[i]);
                }
                return result;
            },
            'sum': (list) => {
                if (!Array.isArray(list)) {
                    throw new Error('sum: argument must be a list');
                }
                return list.reduce((acc, val) => acc + val, 0);
            },
            'product': (list) => {
                if (!Array.isArray(list)) {
                    throw new Error('product: argument must be a list');
                }
                return list.reduce((acc, val) => acc * val, 1);
            },
            'average': (list) => {
                if (!Array.isArray(list)) {
                    throw new Error('average: argument must be a list');
                }
                if (list.length === 0) {
                    throw new Error('average: cannot compute average of empty list');
                }
                const sum = list.reduce((acc, val) => acc + val, 0);
                return sum / list.length;
            },
        };
        return env;
    };

    // Eval
    const specialForms = {
      'if': (x, env) => {
        const [test, conseq, alt] = x.slice(1);
        const exp = evalExp(test, env) ? conseq : alt;
        return evalExp(exp, env);
      },
      'cond': (x, env) => {
        for (const [test, exp] of x.slice(1)) {
          if (test === 'else') {
            return evalExp(exp, env);
          }
          if (evalExp(test, env)) {
            return evalExp(exp, env);
          }
        }
        return null;
      },
      'define': (x, env) => {
        const [symbol, exp] = x.slice(1);
        env.data[symbol] = evalExp(exp, env);
      },
      // New: 'let' special form for local bindings
      'let': (x, env) => {
        const [bindings, ...body] = x.slice(1);
        const symbols = bindings.map(binding => binding[0]);
        const values = bindings.map(binding => evalExp(binding[1], env));
        return specialForms['begin'](['begin'].concat(body), new Env(symbols, values, env));
      },
      'let*': (x, env) => {
        const [bindings, ...body] = x.slice(1);
        // Process bindings sequentially, each in the environment built by previous bindings
        let currentEnv = env;
        for (const binding of bindings) {
          const [symbol, exp] = binding;
          const value = evalExp(exp, currentEnv);
          currentEnv = new Env([symbol], [value], currentEnv);
        }
        return specialForms['begin'](['begin'].concat(body), currentEnv);
      },
      'quote': (x, env) => {
        return x.slice(1)[0];
      },
      'set!': (x, env) => {
        const [symbol, exp] = x.slice(1);
        env.find(symbol)[symbol] = evalExp(exp, env);
      },
      'lambda': (x, env) => {
        const [parms, ...body] = x.slice(1);
        return (...args) => {
          // Handle &rest parameters in lambda
          let lambdaParams = [];
          let lambdaArgs = [];
          let restIndex = -1;
          
          // Find &rest parameter if it exists
          for (let i = 0; i < parms.length; i++) {
            if (parms[i] === '&rest') {
              restIndex = i;
              break;
            }
          }
          
          if (restIndex !== -1) {
            // Handle &rest parameters
            if (restIndex + 1 >= parms.length) {
              throw new Error('&rest must be followed by a parameter name');
            }
            
            // Regular parameters before &rest
            lambdaParams = parms.slice(0, restIndex);
            lambdaArgs = args.slice(0, restIndex);
            
            // Rest parameter gets remaining arguments as a list
            const restParam = parms[restIndex + 1];
            const restArgs = args.slice(restIndex);
            
            lambdaParams.push(restParam);
            lambdaArgs.push(restArgs);
            
            // Check if there are parameters after &rest (which is an error)
            if (restIndex + 2 < parms.length) {
              throw new Error('&rest parameter must be the last parameter');
            }
          } else {
            // No &rest, use parameters as-is
            lambdaParams = parms;
            lambdaArgs = args;
          }
          
          const lambdaEnv = new Env(lambdaParams, lambdaArgs, env);
          // Handle multiple body expressions - evaluate all but return the last
          let result;
          for (const expr of body) {
            result = evalExp(expr, lambdaEnv);
          }
          return result;
        };
      },
      'and': (x, env) => {
        let result = true;
        for (const expr of x.slice(1)) {
          result = evalExp(expr, env);
          if (!result) {
            return result;
          }
        }
        return result;
      },
      'or': (x, env) => {
        let result = false;
        for (const expr of x.slice(1)) {
          result = evalExp(expr, env);
          if (result) {
            return result;
          }
        }
        return result;
      },
      // New: 'begin' special form to evaluate a sequence of expressions
      'begin': (x, env) => {
        let result;
        for (const exp of x.slice(1)) {
          result = evalExp(exp, env);
        }
        return result;
      },
      // Macro support - defmacro defines a macro
      'defmacro': (x, env) => {
        const [name, params, body] = x.slice(1);
        const macro = (...args) => {
          // Handle &rest parameters
          let macroParams = [];
          let macroArgs = [];
          let restIndex = -1;
          
          // Find &rest parameter if it exists
          for (let i = 0; i < params.length; i++) {
            if (params[i] === '&rest') {
              restIndex = i;
              break;
            }
          }
          
          if (restIndex !== -1) {
            // Handle &rest parameters
            if (restIndex + 1 >= params.length) {
              throw new Error('&rest must be followed by a parameter name');
            }
            
            // Regular parameters before &rest
            macroParams = params.slice(0, restIndex);
            macroArgs = args.slice(0, restIndex);
            
            // Rest parameter gets remaining arguments as a list
            const restParam = params[restIndex + 1];
            const restArgs = args.slice(restIndex);
            
            macroParams.push(restParam);
            macroArgs.push(restArgs);
            
            // Check if there are parameters after &rest (which is an error)
            if (restIndex + 2 < params.length) {
              throw new Error('&rest parameter must be the last parameter');
            }
          } else {
            // No &rest, use parameters as-is
            macroParams = params;
            macroArgs = args;
          }
          
          // Create a new environment with macro parameters bound to arguments
          const macroEnv = new Env(macroParams, macroArgs, env);
          // Evaluate the macro body to get the expanded form
          const expanded = evalExp(body, macroEnv);
          // Evaluate the expanded form in the original environment
          return evalExp(expanded, env);
        };
        macro.isMacro = true;
        env.data[name] = macro;
      }
    };

    const evalExp = (x, env) => {
        // Handle empty lists, which caused the 'undefined' error
        if (Array.isArray(x) && x.length === 0) {
            return x;
        }

        // Fix: Check if the string is a literal before looking it up
        if (typeof x === 'string') {
            if (x.startsWith('"') && x.endsWith('"')) {
                // It's a string literal, return it as-is
                return x;
            }
            // It's a symbol, look it up in the environment
            return env.find(x)[x];
        }
        
        if (!Array.isArray(x)) {
            return x;
        }
        const [first, ...rest] = x;
        
        if (specialForms.hasOwnProperty(first)) {
            return specialForms[first](x, env);
        } else {
            const proc = evalExp(first, env);
            if (typeof proc === 'function') {
                if (proc.isMacro) {
                    // For macros, pass unevaluated arguments
                    return proc(...rest);
                } else {
                    // For regular functions, evaluate arguments first
                    const args = rest.map(arg => evalExp(arg, env));
                    return proc(...args);
                }
            } else {
                throw new Error(`'${first}' is not a procedure`);
            }
        }
    };

    const bootstrap = (env) => {
        const bootstrapCode = `
        ; defun implemented as a macro with &rest support for multiple body expressions
        (defmacro defun (name params &rest body)
            (list 'define name (cons 'lambda (cons params body))))
        
        ; progn macro - evaluate multiple expressions and return the last one
        (defmacro progn (&rest expressions)
            (cons 'begin expressions))
        
        ; when macro with &rest support for multiple body expressions
        (defmacro when (test &rest body)
            (list 'if test (cons 'begin body)))
        
        ; unless macro with &rest support for multiple body expressions  
        (defmacro unless (test &rest body)
            (list 'if (list 'not test) (cons 'begin body)))

        ; Standard functions implemented in Lisp
        (defun abs (x) (if (< x 0) (- x) x))
        (defun not (x) (if x #f #t))
        
        ; max with elegant recursive implementation using apply
        (defun max (&rest args)
            (if (null? (cdr args))
                (car args)
                (let ((rest-max (apply max (cdr args))))
                    (if (> (car args) rest-max) (car args) rest-max))))
        
        ; min with elegant recursive implementation using apply
        (defun min (&rest args)
            (if (null? (cdr args))
                (car args)
                (let ((rest-min (apply min (cdr args))))
                    (if (< (car args) rest-min) (car args) rest-min))))

        ; length is now tail-recursive with a helper
        (defun length-aux (l count)
            (if (null? l)
              count
              (length-aux (cdr l) (+ 1 count))))
        (defun length (l)
            (length-aux l 0))

        ; append is now tail-recursive with a helper
        (defun append-aux (l1 l2)
            (if (null? l1)
              l2
              (cons (car l1) (append-aux (cdr l1) l2))))
        (defun append (l1 l2) (append-aux l1 l2))

        ; reverse is now tail-recursive with an accumulator
        (defun reverse-aux (l acc)
            (if (null? l)
              acc
              (reverse-aux (cdr l) (cons (car l) acc))))
        (defun reverse (l)
            (reverse-aux l '()))

        ; map is now tail-recursive with a helper and an accumulator
        (defun map-aux (f l acc)
            (if (null? l)
              (reverse acc)
              (map-aux f (cdr l) (cons (f (car l)) acc))))
        (defun map (f l)
            (map-aux f l '()))

        ; filter is now tail-recursive with a helper and an accumulator
        (defun filter-aux (p l acc)
            (if (null? l)
              (reverse acc)
              (if (p (car l))
                (filter-aux p (cdr l) (cons (car l) acc))
                (filter-aux p (cdr l) acc))))
        (defun filter (p l)
            (filter-aux p l '()))
            
        ; New: zip function to combine two lists into a list of pairs
        (defun zip-aux (l1 l2 acc)
            (if (or (null? l1) (null? l2))
              (reverse acc)
              (zip-aux (cdr l1) (cdr l2) (cons (list (car l1) (car l2)) acc))))
        (defun zip (l1 l2) (zip-aux l1 l2 '()))

        ; reduce is now implemented in JavaScript (non-recursive)
              
        (defun list? (x)
            (cond
              ((null? x) #t)
              ((pair? x) (list? (cdr x)))
              (else #f)))

        (defun cadr (x) (car (cdr x)))
        (defun caddr (x) (car (cdr (cdr x))))
        
        ; Additional utility functions for real-world use
        
        ; String functions (working with string literals)
        (defun string-length (s) (length (cons 'dummy s))) ; Placeholder - would need JS implementation
        
        ; Mathematical functions
        (defun square (x) (* x x))
        (defun cube (x) (* x x x))
        (defun power (base exp)
            (if (= exp 0)
                1
                (if (= exp 1)
                    base
                    (* base (power base (- exp 1))))))
        (defun factorial (n)
            (if (<= n 1)
                1
                (* n (factorial (- n 1)))))
        
        ; List utilities
        (defun first (l) (car l))
        (defun second (l) (cadr l))
        (defun third (l) (caddr l))
        (defun last (l)
            (if (null? (cdr l))
                (car l)
                (last (cdr l))))
        (defun butlast (l)
            (if (null? (cdr l))
                '()
                (cons (car l) (butlast (cdr l)))))
        (defun nth (n l)
            (if (or (null? l) (< n 0))
                #f
                (if (= n 0)
                    (car l)
                    (nth (- n 1) (cdr l)))))
        
        ; List predicates
        (defun empty? (l) (null? l))
        (defun single? (l) (and (pair? l) (null? (cdr l))))
        
        ; List transformations
        (defun take (n l)
            (if (or (= n 0) (null? l))
                '()
                (cons (car l) (take (- n 1) (cdr l)))))
        (defun drop (n l)
            (if (or (= n 0) (null? l))
                l
                (drop (- n 1) (cdr l))))
        (defun flatten-aux (l acc)
            (if (null? l)
                (reverse acc)
                (if (list? (car l))
                    (flatten-aux (cdr l) (append (reverse (flatten (car l))) acc))
                    (flatten-aux (cdr l) (cons (car l) acc)))))
        (defun flatten (l) (flatten-aux l '()))
        
        ; Higher-order functions
        (defun compose (f g) (lambda (x) (f (g x))))
        (defun partial (f &rest args) (lambda (&rest more-args) (apply f (append args more-args))))
        (defun curry (f) (lambda (x) (lambda (y) (f x y))))
        
        ; Functional programming utilities
        (defun identity (x) x)
        (defun constantly (x) (lambda (&rest args) x))
        (defun complement (f) (lambda (&rest args) (not (apply f args))))
        
        ; List searching and finding
        (defun find (predicate l)
            (if (null? l)
                #f
                (if (predicate (car l))
                    (car l)
                    (find predicate (cdr l)))))
        (defun member? (item l)
            (if (null? l)
                #f
                (if (equal? item (car l))
                    #t
                    (member? item (cdr l)))))
        (defun position (item l)
            (define pos-aux (lambda (item l index)
                (if (null? l)
                    #f
                    (if (equal? item (car l))
                        index
                        (pos-aux item (cdr l) (+ index 1))))))
            (pos-aux item l 0))
        
        ; Association lists (key-value pairs)
        (defun assoc (key alist)
            (if (null? alist)
                #f
                (if (equal? key (car (car alist)))
                    (car alist)
                    (assoc key (cdr alist)))))
        (defun alist-get (key alist)
            (let ((pair (assoc key alist)))
                (if pair (car (cdr pair)) #f)))
        (defun alist-set (key value alist)
            (cons (list key value) alist))
        
        ; Sorting (simple insertion sort)
        (defun insert-sorted (item l compare)
            (if (null? l)
                (list item)
                (if (compare item (car l))
                    (cons item l)
                    (cons (car l) (insert-sorted item (cdr l) compare)))))
        (defun sort (l compare)
            (if (null? l)
                '()
                (insert-sorted (car l) (sort (cdr l) compare) compare)))
        
        ; Numeric utilities
        (defun even? (n) (= (mod n 2) 0))
        (defun odd? (n) (= (mod n 2) 1))
        (defun positive? (n) (> n 0))
        (defun negative? (n) (< n 0))
        (defun zero? (n) (= n 0))
        ; sum, product, and average are now implemented in JavaScript (non-recursive)
        
        ; Conditional utilities  
        (defmacro cond* (&rest clauses)
            (if (null? clauses)
                #f
                (let ((clause (car clauses)))
                    (if (equal? (car clause) 'else)
                        (cadr clause)
                        (list 'if (car clause) (cadr clause) (cons 'cond* (cdr clauses)))))))
        
        ; Loop-like constructs
        (defmacro dotimes (binding &rest body)
            (let ((var (car binding)) (times (cadr binding)))
                (list 'for-each (cons 'lambda (cons (list var) body)) (list 'range 0 times))))
        `;

        try {
            const tokens = tokenize(bootstrapCode);
            while (tokens.length > 0) {
                const expr = readFromTokens(tokens);
                evalExp(expr, env);
            }
        } catch (e) {
            console.error('Error during bootstrap:', e);
        }
    };

    const selfTest = (env, printLine) => {
        const tests = [
            // Arithmetic tests
            ['(+ 1 2 3)', 6, 'Simple addition'],
            ['(- 10 5)', 5, 'Simple subtraction'],
            ['(* 2 3 4)', 24, 'Multi-parameter multiplication'],
            ['(/ 20 4 2)', 2.5, 'Multi-parameter division'],
            ['(= 10 10)', true, 'eq on numbers'],
            ['(= #t #t)', true, 'eq on booleans'],
            ['(equal? "hello" "hello")', true, 'equal? on strings'],
            
            // List and logic tests
            ['(length (list 1 2 3 4 5))', 5, 'length of a list'],
            ['(equal? (reverse (list 1 2 3)) (list 3 2 1))', true, 'reverse and equal?'],
            ['(and #t #f #t)', false, 'and short-circuiting'],
            ['(or #f #f #t)', true, 'or short-circuiting'],
            ['(null? (list))', true, 'null? on an empty list'],
            ['(list? (list 1 2))', true, 'list? on a list'],
            ['(list? 123)', false, 'list? on a number'],
            // Test Cases for `defun` and `let`
            ['(defun square (x) (* x x))', null, 'Defines a function `square`'],
            ['(equal? (square 5) 25)', true, 'Tests the new `square` function'],
            ['(let ((x 10)) (+ x 5))', 15, 'let with a single binding'],
            ['(let ((x 10) (y 5)) (+ x y))', 15, 'let with multiple bindings'],
            
            // Test Cases for macros and defmacro with &rest support
            ['(defmacro simple-when (test body) (list (quote if) test body))', null, 'Defines a simple macro `simple-when`'],
            ['(simple-when #t 42)', 42, 'Tests the simple `when` macro with true condition'],
            ['(simple-when #f 42)', null, 'Tests the simple `when` macro with false condition'],
            
            // Test &rest parameter support in macros
            ['(defmacro list-maker (&rest args) (cons (quote list) args))', null, 'Defines macro with &rest parameter'],
            ['(equal? (list-maker 1 2 3 4) (list 1 2 3 4))', true, 'Tests macro with &rest parameter'],
            
            // Test enhanced when/unless with multiple body expressions
            ['(when #t 1 2 3)', 3, 'Tests enhanced `when` macro with multiple body expressions'],
            ['(unless #f 10 20 30)', 30, 'Tests enhanced `unless` macro with multiple body expressions'],
            
            // Test progn macro
            ['(progn 1 2 3 4)', 4, 'Tests `progn` macro - returns last expression'],
            
            // Test dotimes macro
            ['(begin (define total 0) (dotimes (i 5) (set! total (+ total i))) total)', 10, 'Tests `dotimes` macro: sum of 0+1+2+3+4'],
            
            // Test let* macro (sequential bindings)
            ['(let* ((x 5) (y (* x x))) (list y))', [25], 'Tests `let*` macro: sequential binding where y uses x'],
            ['(let* ((a 3) (b (+ a 2)) (c (* a b))) c)', 15, 'Tests `let*` macro: multiple sequential bindings'],
            
            // Test enhanced defun with multiple body expressions
            ['(defun test-multi-body (x) (set! x (+ x 1)) (set! x (* x 2)) x)', null, 'Defines function with multiple body expressions'],
            ['(test-multi-body 5)', 12, 'Tests function with multiple body expressions: (5+1)*2=12'],
            
            // Test that defun is really a macro (it should expand to define + lambda)
            ['(defun factorial (n) (if (= n 0) 1 (* n (factorial (- n 1)))))', null, 'Defines factorial function via enhanced defun macro'],
            ['(factorial 5)', 120, 'Tests factorial function defined via enhanced defun macro'],
            
            // Test Case for `zip`
            ['(equal? (zip (list 1 2) (list "a" "b")) (list (list 1 "a") (list 2 "b")))', true, 'zip function'],

            // New test cases for `range` and `for-each`
            ['(equal? (range 1 5) (list 1 2 3 4))', true, 'range function generates a list with default increment'],
            ['(equal? (range 1 10 2) (list 1 3 5 7 9))', true, 'range function with increment of 2'],
            ['(equal? (range 0 6 3) (list 0 3))', true, 'range function with increment of 3'],
            ['(equal? (range 2 8 1) (list 2 3 4 5 6 7))', true, 'range function with explicit increment of 1'],
            ["(let ((acc '())) (for-each (lambda (x) (set! acc (cons x acc))) (list 1 2 3)) (equal? (reverse acc) (list 1 2 3)))", true, 'for-each with side effects and a `begin` block'],

            // Higher-order function tests
            ['(equal? (map (lambda (x) (* x x)) (list 1 2 3)) (list 1 4 9))', true, 'map function'],
            ['(equal? (filter (lambda (x) (> x 2)) (list 1 2 3 4 5)) (list 3 4 5))', true, 'filter function'],
            
            // Test functions moved to bootstrap
            ['(abs -5)', 5, 'abs function with negative number'],
            ['(abs 5)', 5, 'abs function with positive number'],
            ['(not #t)', false, 'not function with true'],
            ['(not #f)', true, 'not function with false'],
            ['(max 1 5 3 2)', 5, 'max function with multiple arguments'],
            ['(min 1 5 3 2)', 1, 'min function with multiple arguments'],
            
            // Test apply function
            ['(apply + (list 1 2 3 4))', 10, 'apply function with addition'],
            ['(apply max (list 1 5 3 2))', 5, 'apply function with max'],
            ['(equal? (apply list (list 1 2 3)) (list 1 2 3))', true, 'apply function with list'],
            ['(max 42)', 42, 'max function with single argument'],
            ['(min 42)', 42, 'min function with single argument'],
            ['(apply + (range 1 6))', 15, 'apply with range: sum of 1+2+3+4+5'],
            
            // Test newly added mathematical functions
            ['(square 5)', 25, 'square function'],
            ['(cube 3)', 27, 'cube function'],
            ['(power 2 3)', 8, 'power function'],
            ['(power 5 0)', 1, 'power function with exponent 0'],
            ['(factorial 4)', 24, 'factorial function'],
            ['(factorial 0)', 1, 'factorial of 0'],
            
            // Test numeric predicates
            ['(even? 4)', true, 'even? predicate with even number'],
            ['(even? 3)', false, 'even? predicate with odd number'],
            ['(odd? 3)', true, 'odd? predicate with odd number'],
            ['(odd? 4)', false, 'odd? predicate with even number'],
            ['(positive? 5)', true, 'positive? predicate'],
            ['(negative? -3)', true, 'negative? predicate'],
            ['(zero? 0)', true, 'zero? predicate'],
            
            // Test list accessors
            ['(first (list 1 2 3))', 1, 'first function'],
            ['(second (list 1 2 3))', 2, 'second function'],
            ['(third (list 1 2 3 4))', 3, 'third function'],
            ['(last (list 1 2 3 4))', 4, 'last function'],
            ['(equal? (butlast (list 1 2 3 4)) (list 1 2 3))', true, 'butlast function'],
            ['(nth 2 (list 1 2 3 4))', 3, 'nth function'],
            
            // Test list predicates
            ['(empty? (list))', true, 'empty? predicate with empty list'],
            ['(empty? (list 1))', false, 'empty? predicate with non-empty list'],
            ['(single? (list 42))', true, 'single? predicate with single item'],
            ['(single? (list 1 2))', false, 'single? predicate with multiple items'],
            
            // Test list transformations
            ['(equal? (take 2 (list 1 2 3 4)) (list 1 2))', true, 'take function'],
            ['(equal? (drop 2 (list 1 2 3 4)) (list 3 4))', true, 'drop function'],
            ['(equal? (flatten (list (list 1 2) 3 (list 4 5))) (list 1 2 3 4 5))', true, 'flatten function'],
            
            // Test statistical functions
            ['(reduce + 0 (list 1 2 3 4))', 10, 'reduce function test'],
            ['(reduce * 1 (list 2 3 4))', 24, 'reduce with multiplication test'],
            ['(sum (list 1 2 3 4))', 10, 'sum function'],
            ['(product (list 2 3 4))', 24, 'product function'],
            ['(average (list 2 4 6))', 4, 'average function'],
            
            // Test higher-order functions
            ['((compose abs -) 5)', 5, 'compose function: abs of negation'],
            ['(((curry +) 10) 5)', 15, 'curry function'],
            ['((partial + 10 20) 5)', 35, 'partial function'],
            ['(identity 42)', 42, 'identity function'],
            ['((constantly 42) 1 2 3)', 42, 'constantly function'],
            ['((complement null?) (list 1 2))', true, 'complement function'],
            
            // Test list searching
            ['(find (lambda (x) (> x 3)) (list 1 2 4 5))', 4, 'find function'],
            ['(member? 3 (list 1 2 3 4))', true, 'member? function - found'],
            ['(member? 5 (list 1 2 3 4))', false, 'member? function - not found'],
            ['(position 3 (list 1 2 3 4))', 2, 'position function'],
            ['(position 99 (list 1 2 3 4))', false, 'position function - not found'],
            
            // Test association lists
            ['(equal? (assoc "name" (list (list "name" "John") (list "age" 30))) (list "name" "John"))', true, 'assoc function'],
            ['(alist-get "name" (list (list "name" 42) (list "age" 30)))', 42, 'alist-get function'],
            ['(equal? (alist-set "city" "NYC" (list (list "name" "Bob"))) (list (list "city" "NYC") (list "name" "Bob")))', true, 'alist-set function'],
            
            // Test sorting
            ['(equal? (sort (list 3 1 4 2) <) (list 1 2 3 4))', true, 'sort function with < comparator'],
            ['(equal? (sort (list 3 1 4 2) >) (list 4 3 2 1))', true, 'sort function with > comparator'],
        ];

        printLine('--- Running self-tests ---', 'subtitle');
        let passedCount = 0;
        let totalCount = tests.length;
        
        tests.forEach(([expression, expected, description]) => {
            let passed = false;
            try {
                const result = evalExp(parse(expression), env);
                if (deepEqual(result, expected) || (result === undefined && expected === null)) {
                    passed = true;
                    passedCount++;
                }
            } catch (e) {
                // If an error is thrown, the test fails
            }
            const status = passed ? '✅ PASS' : '❌ FAIL';
            printLine(`${status}: ${description}`, passed ? 'prompt' : 'result');
        });
        
        // Print summary
        const failedCount = totalCount - passedCount;
        if (failedCount === 0) {
            printLine(`🎉 All ${totalCount} tests passed!`, 'prompt');
        } else {
            printLine(`⚠️  ${failedCount} of ${totalCount} tests failed (${passedCount} passed)`, 'result');
        }
        printLine('--- Self-tests complete ---', 'subtitle');
    };

    const repl = () => {
        const inputElement = document.getElementById('repl-input');
        const outputElement = document.getElementById('repl-output');
        const runButton = document.getElementById('run-btn');
        const env = standardEnv();

        bootstrap(env);
        selfTest(env, (text, className) => {
            const p = document.createElement('div');
            p.className = className;
            p.textContent = text;
            outputElement.appendChild(p);
            outputElement.scrollTop = outputElement.scrollHeight;
        });

        let commandHistory = [];
        let historyIndex = -1;
        let inHistoryMode = false; // Track if we're navigating history

        const printLine = (text, className = '') => {
            const p = document.createElement('div');
            p.className = className;
            p.textContent = text;
            outputElement.appendChild(p);
            outputElement.scrollTop = outputElement.scrollHeight;
        };

        const handleRun = () => {
            const program = inputElement.value.trim();
            if (program === '') return;

            printLine(`> ${program}`, 'prompt');
            commandHistory.push(program);
            historyIndex = commandHistory.length;
            inHistoryMode = false; // Exit history mode after running command

            try {
                // Handle multiple statements like bootstrap code
                const tokens = tokenize(program);
                let lastResult = null;
                
                while (tokens.length > 0) {
                    const expr = readFromTokens(tokens);
                    lastResult = evalExp(expr, env);
                }
                
                // Only print the result of the last expression
                if (lastResult !== null) {
                    printLine(toString(lastResult), 'result');
                }
            } catch (e) {
                printLine(`Error: ${e.message}`, 'result');
            }
            inputElement.value = '';
        };

        const handleHistory = (event) => {
            // Start history navigation if input is empty OR continue if already in history mode
            if (inputElement.value.trim() === '' || inHistoryMode) {
                if (event.key === 'ArrowUp') {
                    if (historyIndex > 0) {
                        event.preventDefault(); // Prevent default cursor movement
                        historyIndex--;
                        inputElement.value = commandHistory[historyIndex];
                        inHistoryMode = true; // Now in history navigation mode
                        // Keep cursor at the end
                        setTimeout(() => inputElement.setSelectionRange(inputElement.value.length, inputElement.value.length), 0);
                    }
                } else if (event.key === 'ArrowDown') {
                    if (historyIndex < commandHistory.length - 1) {
                        event.preventDefault(); // Prevent default cursor movement
                        historyIndex++;
                        inputElement.value = commandHistory[historyIndex];
                        inHistoryMode = true; // Stay in history navigation mode
                        setTimeout(() => inputElement.setSelectionRange(inputElement.value.length, inputElement.value.length), 0);
                    } else if (historyIndex === commandHistory.length - 1) {
                        event.preventDefault(); // Prevent default cursor movement
                        historyIndex++;
                        inputElement.value = '';
                        inHistoryMode = false; // Exit history mode when we clear input
                    }
                }
            }
            // If not in history mode and input has text, let browser handle normal arrow key navigation
        };

        runButton.addEventListener('click', handleRun);
        inputElement.addEventListener('keydown', (event) => {
            // If in history mode and user presses any key except arrows, exit history mode
            if (inHistoryMode && !['ArrowUp', 'ArrowDown'].includes(event.key)) {
                // Don't exit on modifier keys or special keys that don't change content
                if (!['Control', 'Alt', 'Meta', 'Shift', 'CapsLock', 'Tab', 'Escape'].includes(event.key)) {
                    inHistoryMode = false;
                }
            }
            
            if (event.ctrlKey && event.key === 'Enter') {
                event.preventDefault();
                handleRun();
            } else {
                handleHistory(event);
            }
        });
        
        // Exit history mode when user starts typing
        inputElement.addEventListener('input', () => {
            if (inHistoryMode) {
                inHistoryMode = false; // Exit history mode when user modifies text
            }
        });
        
        // Add click handler for sidebar functions
        document.querySelectorAll('.function-list li').forEach(item => {
            item.addEventListener('click', (e) => {
                // Prevent tooltip from interfering
                if (e.target.classList.contains('tooltiptext') || e.target.closest('.tooltiptext')) {
                    return;
                }
                
                // Extract function name - it's the text content after the marker span
                let functionName = '';
                for (let node of item.childNodes) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        functionName = node.textContent.trim();
                        break;
                    }
                }
                
                const currentValue = inputElement.value;
                
                // Function templates with parameter placeholders
                const functionTemplates = {
                    // Special Forms
                    'if': '(if test then-expr else-expr)',
                    'cond': '(cond (test1 result1) (test2 result2) (else default-result))',
                    'define': '(define symbol value)',
                    'let': '(let ((var1 val1) (var2 val2)) body)',
                    'let*': '(let* ((var1 val1) (var2 val2)) body)',
                    'quote': '(quote expression)',
                    'set!': '(set! symbol new-value)',
                    'lambda': '(lambda (param1 param2) body)',
                    'and': '(and expr1 expr2)',
                    'or': '(or expr1 expr2)',
                    'begin': '(begin expr1 expr2)',
                    'defmacro': '(defmacro name (param1 param2) body)',
                    
                    // Macros
                    'defun': '(defun name (param1 param2) body)',
                    'progn': '(progn expr1 expr2)',
                    'when': '(when test body)',
                    'unless': '(unless test body)',
                    'dotimes': '(dotimes (var count) body)',
                    
                    // Arithmetic
                    '+': '(+ num1 num2)',
                    '-': '(- num1 num2)',
                    '*': '(* num1 num2)',
                    '/': '(/ num1 num2)',
                    'abs': '(abs number)',
                    'round': '(round number)',
                    'max': '(max num1 num2 num3)',
                    'min': '(min num1 num2 num3)',
                    
                    // Comparison
                    '=': '(= num1 num2)',
                    '>': '(> num1 num2)',
                    '<': '(< num1 num2)',
                    '>=': '(>= num1 num2)',
                    '<=': '(<= num1 num2)',
                    'eq': '(eq obj1 obj2)',
                    'equal?': '(equal? obj1 obj2)',
                    
                    // Lists
                    'car': '(car list)',
                    'cdr': '(cdr list)',
                    'cadr': '(cadr list)',
                    'caddr': '(caddr list)',
                    'cons': '(cons item list)',
                    'list': '(list item1 item2 item3)',
                    'append': '(append list1 list2)',
                    'reverse': '(reverse list)',
                    'length': '(length list)',
                    'map': '(map function list)',
                    'filter': '(filter predicate list)',
                    'reduce': '(reduce function initial-value list)',
                    'zip': '(zip list1 list2)',
                    'range': '(range start end step)',
                    'for-each': '(for-each function list)',
                    'sum': '(sum list)',
                    'product': '(product list)',
                    'average': '(average list)',
                    
                    // Predicates
                    'null?': '(null? obj)',
                    'pair?': '(pair? obj)',
                    'list?': '(list? obj)',
                    'number?': '(number? obj)',
                    'symbol?': '(symbol? obj)',
                    'procedure?': '(procedure? obj)',
                    
                    // Logic & Control
                    'not': '(not expr)',
                    'for-each': '(for-each function list)',
                    'apply': '(apply function argument-list)',
                    
                    // Utility
                    'error': '(error "message")'
                };
                
                const template = functionTemplates[functionName] || `(${functionName} )`;
                
                // If input is empty, just add the template
                if (currentValue.trim() === '') {
                    inputElement.value = template;
                } else {
                    // Add a newline and the template
                    inputElement.value = currentValue + '\n' + template;
                }
                
                // Focus the input and position cursor after opening parenthesis for easy editing
                inputElement.focus();
                const openParenPos = inputElement.value.lastIndexOf('(') + functionName.length + 2;
                inputElement.setSelectionRange(openParenPos, openParenPos);
            });
        });
        
        // Dynamic tooltip positioning
        const tooltips = document.querySelectorAll('.tooltip');
        tooltips.forEach(tooltip => {
            const tooltipText = tooltip.querySelector('.tooltiptext');
            
            tooltip.addEventListener('mouseenter', function(e) {
                const rect = e.target.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // Position tooltip to the right of the sidebar
                let left = rect.right + 10;
                let top = rect.top;
                
                // Adjust if tooltip would go off screen
                if (left + 300 > viewportWidth) {
                    left = viewportWidth - 320; // 300px width + 20px margin
                }
                
                // Adjust vertical position if needed
                if (top + 100 > viewportHeight) {
                    top = viewportHeight - 120;
                }
                
                if (top < 0) {
                    top = 10;
                }
                
                tooltipText.style.left = left + 'px';
                tooltipText.style.top = top + 'px';
                tooltipText.style.transform = 'none';
            });
        });
        
        printLine('Lisp REPL ready. Start typing expressions above!', 'subtitle');
    };

    window.onload = function() {
        repl();
    };
</script>

</body>
</html>
